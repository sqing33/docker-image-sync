name: å®šæœŸæ›´æ–° ghcr.io é•œåƒ

on:
  schedule:
    - cron: "0 16 * * *"
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    steps:
      - name: æ£€å‡ºä»“åº“
        uses: actions/checkout@v4

      - name: å®‰è£…ä¾èµ–
        run: sudo apt-get install -y jq skopeo

      - name: æå–æºé•œåƒåˆ—è¡¨
        id: extract-images
        run: |
          awk -F '|' '
          /^### å·²åŒæ­¥ Docker é•œåƒ/ {capture=1; next}
          capture && /^\| [0-9]+/ {
              gsub(/^[ \t]+|[ \t]+$/, "", $3);
              gsub(/`/, "", $3);
              print $3
          }
          /^### éƒ¨åˆ†é•œåƒ docker run å‘½ä»¤/ {capture=0}
          ' README.md | grep -vE '^æºé•œåƒ$|^-+$' | sed '/^$/d' > image-list.txt

      - name: ç™»å½•åˆ° GitHub å®¹å™¨æ³¨å†Œè¡¨
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: æ¸…ç†å·²åˆ é™¤çš„é•œåƒæ¡ç›®
        env:
          GHCR_USER: ${{ github.repository_owner }}
        run: |
          # ç”Ÿæˆéœ€è¦ä¿ç•™çš„é•œåƒåˆ—è¡¨
          touch keep-images.txt
          while IFS= read -r image; do
            image_name=$(basename "$image")
            target_image="ghcr.io/$(echo "$GHCR_USER" | tr 'A-Z' 'a-z')/$image_name"
            if skopeo inspect "docker://$target_image:latest" >/dev/null 2>&1; then
              echo "$image" >> keep-images.txt
            else
              echo "é•œåƒ $image ä¸å­˜åœ¨äºghcr.ioï¼Œæ ‡è®°ä¸ºåˆ é™¤"
              # è®°å½•éœ€è¦åˆ é™¤çš„é•œåƒåç§°ï¼ˆç”¨äºå¤„ç†READMEï¼‰
              echo "$image" >> deleted-images.txt
            fi
          done < image-list.txt

          # ä»…åœ¨æ–‡ä»¶å­˜åœ¨æ—¶è¾“å‡ºå†…å®¹ï¼ˆé¿å…æŠ¥é”™ï¼‰
          if [ -f "deleted-images.txt" ]; then
            echo "ä»¥ä¸‹é•œåƒå°†è¢«æ¸…ç†ï¼š"
            cat deleted-images.txt
          fi

          # æ›´æ–°é•œåƒåˆ—è¡¨ä¸ºä»…ä¿ç•™å­˜åœ¨çš„é•œåƒ
          mv keep-images.txt image-list.txt

          # å¦‚æœå­˜åœ¨éœ€è¦åˆ é™¤çš„æ¡ç›®ï¼Œæ›´æ–°README.md
          if [ -f deleted-images.txt ]; then
            echo "å¼€å§‹æ¸…ç†READMEä¸­çš„æ— æ•ˆæ¡ç›®..."
            while IFS= read -r del_image; do
              # ä½¿ç”¨ç«–çº¿ä½œä¸ºåˆ†éš”ç¬¦ï¼Œå¹¶å…è®¸åˆ—å‰åæœ‰ç©ºæ ¼
              escaped_del_image=$(printf '%s\n' "$del_image" | sed 's/[]\[\*\^$.\/?+(){}|]/\\&/g')
              sed -i "/| *[0-9]\+ *| *$escaped_del_image *|/d" README.md
            done < deleted-images.txt

            # é‡æ–°ç¼–å·å¹¶ä¿®å¤è¡¨æ ¼æ ¼å¼ï¼ˆä¿æŒåŸæœ‰ä»£ç ä¸å˜ï¼‰
            awk -F '|' '
              BEGIN { count=0 }
              /^### å·²åŒæ­¥ Docker é•œåƒ/ { 
                print
                count=0
                next
              }
              /^\| *----/ { print; next }
              /^\| *[0-9]+/ {
                count++
                spaces_before = match($2, /^ */) ? substr($2, 1, RLENGTH) : ""
                spaces_after = match($2, / *$/) ? substr($2, RSTART) : ""
                $2 = sprintf("%s%d%s", spaces_before, count, spaces_after)
                printf "|%s", $2
                for (i=3; i<=NF; i++) printf "|%s", $i
                print ""
                next
              }
              { print }
            ' README.md > README.tmp && mv README.tmp README.md

            # æäº¤æ›´æ”¹ï¼ˆä¿æŒåŸæœ‰ä»£ç ä¸å˜ï¼‰
            git config --global user.name "GitHub Actions"
            git config --global user.email "actions@github.com"
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            git add README.md
            git commit -m "è‡ªåŠ¨æ¸…ç†å·²åˆ é™¤çš„é•œåƒæ¡ç›®" || echo "æ— å˜æ›´å¯æäº¤"
            git push origin main
          fi

      - name: åŒæ­¥æ‰€æœ‰æ¶æ„é•œåƒæ›´æ–°
        env:
          GHCR_USER: ${{ github.repository_owner }}
        run: |
          echo "===== åŒæ­¥é•œåƒåˆ—è¡¨ ====="
          cat image-list.txt
          echo "===================="

          while IFS= read -r source_image; do
            echo "å¤„ç†é•œåƒ: $source_image"
            source_image_full="docker://$( [[ "$source_image" == *"/"* ]] && echo "$source_image" || echo "library/$source_image" ):latest"
            image_name=$(basename "$source_image")
            target_image_base="ghcr.io/$(echo "$GHCR_USER" | tr 'A-Z' 'a-z')/$image_name"
            need_update=false

            # è·å–æºé•œåƒæ¸…å•åˆ—è¡¨
            source_manifest=$(skopeo inspect --raw "$source_image_full")
            source_digest=$(echo "$source_manifest" | jq -r '.digest')

            # æ£€æŸ¥ç›®æ ‡é•œåƒæ˜¯å¦å­˜åœ¨
            if target_manifest=$(skopeo inspect --raw "docker://$target_image_base:latest" 2>/dev/null); then
              target_digest=$(echo "$target_manifest" | jq -r '.digest')
            else
              target_digest=""
            fi

            # æ¯”è¾ƒæ¸…å• digest
            if [ "$source_digest" != "$target_digest" ]; then
              echo "æ£€æµ‹åˆ°æ¸…å•æ›´æ–°ï¼Œå¼€å§‹å…¨æ¶æ„åŒæ­¥..."
              need_update=true
            else
              echo "æ¸…å•æœªæ›´æ–°ï¼Œè·³è¿‡åŒæ­¥"
              continue
            fi

            # è·å–æ‰€æœ‰æ”¯æŒçš„æ¶æ„
            if echo "$source_manifest" | jq -e '.manifests' > /dev/null 2>&1; then
              ARCHS=$(echo "$source_manifest" | jq -r '.manifests[].platform.architecture' | sort -u | grep -E 'amd64|arm64|arm|386|ppc64le|s390x|mips64le')
            else
              ARCH=$(echo "$source_manifest" | jq -r '.architecture')
              ARCHS=$( [[ "$ARCH" =~ ^(amd64|arm64|arm|386|ppc64le|s390x|mips64le)$ ]] && echo "$ARCH" || echo "")
            fi

            if [ -z "$ARCHS" ]; then
              echo "âŒ æœªæ‰¾åˆ°æ”¯æŒçš„æ¶æ„ï¼Œä½¿ç”¨é»˜è®¤æ¶æ„ amd64"
              ARCHS="amd64"
            fi

            # åŒæ­¥å„æ¶æ„é•œåƒ
            for arch in $ARCHS; do
              echo "â–¸ å¤„ç†æ¶æ„: $arch"
              target_tag="$target_image_base:latest-$arch"
              
              # è·å–æ¶æ„ç‰¹å®š digest
              arch_digest=$(echo "$source_manifest" | jq -r \
                '.manifests[] | select(.platform.architecture == "'$arch'").digest')

              # æ‹‰å–å¹¶æ¨é€æ¶æ„é•œåƒ
              docker pull --platform "linux/$arch" "$(echo "$source_image_full" | sed 's|docker://||')@$arch_digest"
              docker tag "$(echo "$source_image_full" | sed 's|docker://||')@$arch_digest" "$target_tag"
              docker push "$target_tag"
            done

            # æ›´æ–° manifest åˆ—è¡¨
            echo "ğŸ”„ é‡å»ºå¤šæ¶æ„manifeståˆ—è¡¨..."
            docker manifest rm "$target_image_base:latest" 2>/dev/null || true
            amend_args=()
            for arch in $ARCHS; do
              amend_args+=(--amend "$target_image_base:latest-$arch")
            done
            docker manifest create "$target_image_base:latest" "${amend_args[@]}" --insecure
            docker manifest push "$target_image_base:latest"

            echo "âœ… åŒæ­¥å®Œæˆ: $target_image_base:latest"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          done < image-list.txt
