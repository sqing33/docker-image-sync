name: å®šæœŸæ›´æ–° ghcr.io é•œåƒ

on:
  schedule:
    - cron: "0 16 * * *" # æ¯å¤© UTC æ—¶é—´ 16:00 è¿è¡Œ (åŒ—äº¬æ—¶é—´å‡Œæ™¨ 00:00)
  workflow_dispatch: # å…è®¸æ‰‹åŠ¨è§¦å‘

permissions:
  contents: write # å†™å…¥ä»“åº“å†…å®¹ï¼ˆç”¨äºæ›´æ–° README.mdï¼‰
  packages: write # å†™å…¥/åˆ é™¤ GitHub Packages

jobs:
  check-and-update:
    runs-on: ubuntu-latest # åœ¨ Ubuntu æœ€æ–°ç‰ˆæœ¬ä¸Šè¿è¡Œ

    steps:
      - name: æ£€å‡ºä»“åº“
        uses: actions/checkout@v4 # æ£€å‡ºä½ çš„ä»£ç ä»“åº“

      - name: å®‰è£…ä¾èµ–
        run: sudo apt-get install -y jq skopeo # å®‰è£… jq (å¤„ç† JSON) å’Œ skopeo (æ£€æŸ¥/å¤åˆ¶é•œåƒ)

      - name: æå–ç›®æ ‡é•œåƒåç§°ï¼ˆä» pull å‘½ä»¤åˆ—ï¼‰
        id: extract-target-images
        run: |
          awk -F '|' '
          /^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/ {capture=1; next}
          capture && /^\| [0-9]+/ {
              # æå– pull é•œåƒåˆ—ï¼ˆç¬¬3åˆ—ï¼‰
              gsub(/^[ \t]+|[ \t]+$/, "", $4);
              gsub(/`/, "", $4);
              print $4
          }
          /^### éƒ¨åˆ†é•œåƒ docker run å‘½ä»¤/ {capture=0}
          ' README.md | grep -vE '^æºé•œåƒ$|^-+$' | sed '/^$/d' |
          # æå–é•œåƒåç§°ï¼ˆå»é™¤åŸŸåå’Œæ ‡ç­¾ï¼‰
          sed 's|^ghcr.nju.edu.cn/sqing33/||' | # æ³¨æ„ï¼šè¿™é‡Œçš„åŸŸåå’Œç”¨æˆ·å 'sqing33' éœ€è¦ä¸ä½ çš„å®é™…æƒ…å†µåŒ¹é…
          sed 's/:[^:]*$//' > target-image-list.txt
          echo "===== target-image-list.txt å†…å®¹ ====="
          cat target-image-list.txt

      - name: æå–æºé•œåƒåç§°ï¼ˆä»æºé•œåƒåˆ—ï¼‰
        id: extract-source-images
        run: |
          awk -F '|' '
          /^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/ {capture=1; next}
          capture && /^\| [0-9]+/ {
              # æå–æºé•œåƒåˆ—ï¼ˆç¬¬2åˆ—ï¼Œåœ¨åˆ é™¤ç”¨é€”åˆ—åï¼‰
              gsub(/^[ \t]+|[ \t]+$/, "", $3);
              gsub(/`/, "", $3);
              print $3
          }
          /^### éƒ¨åˆ†é•œåƒ docker run å‘½ä»¤/ {capture=0}
          ' README.md | grep -vE '^æºé•œåƒ$|^-+$' | sed '/^$/d' > source-image-list.txt
          echo "===== source-image-list.txt å†…å®¹ ====="
          cat source-image-list.txt

      - name: åˆå¹¶é•œåƒåˆ—è¡¨
        run: |
          # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”éç©º
          if [ ! -s source-image-list.txt ] || [ ! -s target-image-list.txt ]; then
            echo "é”™è¯¯ï¼šsource-image-list.txt æˆ– target-image-list.txt ä¸ºç©ºæˆ–ä¸å­˜åœ¨"
            exit 1
          fi
          paste -d '|' source-image-list.txt target-image-list.txt > combined-list.txt
          echo "===== combined-list.txt å†…å®¹ ====="
          cat combined-list.txt

      - name: ç™»å½•åˆ° GitHub å®¹å™¨æ³¨å†Œè¡¨
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }} # ä½¿ç”¨ä»“åº“æ‰€æœ‰è€…ä½œä¸º GHCR ç”¨æˆ·å
          password: ${{ secrets.GITHUB_TOKEN }}    # ä½¿ç”¨ GitHub Actions é»˜è®¤ token

      - name: æ¸…ç†å·²åˆ é™¤çš„é•œåƒæ¡ç›®
        env:
          GHCR_USER: ${{ github.repository_owner }}
        run: |
          touch keep-images.txt
          while IFS= read -r target_image; do
            target_image_base="ghcr.io/$(echo "$GHCR_USER" | tr 'A-Z' 'a-z')/$target_image"
            # æ£€æŸ¥ ghcr.io ä¸Šæ˜¯å¦å­˜åœ¨æ­¤é•œåƒ
            if skopeo inspect "docker://$target_image_base:latest" >/dev/null 2>&1; then
              echo "$target_image" >> keep-images.txt
            else
              echo "é•œåƒ $target_image ä¸å­˜åœ¨äºghcr.ioï¼Œæ ‡è®°ä¸ºåˆ é™¤"
              echo "$target_image" >> deleted-images.txt
            fi
          done < target-image-list.txt

          mv keep-images.txt target-image-list.txt

          # å¦‚æœå­˜åœ¨éœ€è¦ä» README ä¸­åˆ é™¤çš„æ¡ç›®
          if [ -f deleted-images.txt ]; then
            echo "å¼€å§‹æ¸…ç†READMEä¸­çš„æ— æ•ˆæ¡ç›®..."
            while IFS= read -r del_image; do
              # è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦ä»¥åœ¨ sed ä¸­å®‰å…¨ä½¿ç”¨
              escaped_del_image=$(printf '%s' "$del_image" | sed 's/[][\\\^\$\.\*?+(){}|]/\\&/g')
              # åˆ é™¤åŒ…å« ghcr.nju.edu.cn/GHCR_USER/del_image çš„è¡Œ
              sed -i "/|.*\`ghcr.nju.edu.cn\/$GHCR_USER\/$escaped_del_image\(:[^\`]*\)\?\`/d" README.md
            done < deleted-images.txt

            # é‡æ–°ç¼–å·è¡¨æ ¼å¹¶ä¿®å¤æ ¼å¼
            awk -F '|' '
              BEGIN { count=0 }
              /^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/ {
                print
                count=0
                next
              }
              /^\| *----/ { print; next } # ä¿ç•™åˆ†éš”çº¿
              /^\| *[0-9]+/ { # åŒ¹é…æ•°æ®è¡Œ
                count++
                # ä¿®å¤å¯èƒ½å­˜åœ¨çš„ç¼–å·ä¸¤ä¾§çš„ç©ºæ ¼
                spaces_before = match($2, /^ */) ? substr($2, 1, RLENGTH) : ""
                spaces_after = match($2, / *$/) ? substr($2, RSTART) : ""
                $2 = sprintf("%s%d%s", spaces_before, count, spaces_after)
                printf "|%s", $2
                for (i=3; i<=NF; i++) printf "|%s", $i # æ‰“å°å‰©ä½™åˆ—
                print ""
                next
              }
              { print } # æ‰“å°å…¶ä»–è¡Œ
            ' README.md > README.tmp && mv README.tmp README.md

            # æäº¤æ›´æ”¹
            git config --global user.name "GitHub Actions"
            git config --global user.email "actions@github.com"
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            git add README.md
            git commit -m "è‡ªåŠ¨æ¸…ç†å·²åˆ é™¤çš„é•œåƒæ¡ç›®" || echo "æ— å˜æ›´å¯æäº¤" # å¦‚æœæ²¡æœ‰ä¿®æ”¹ï¼Œåˆ™ä¸æäº¤
            git push origin main

            # ä» combined-list.txt åˆ é™¤å·²æ ‡è®°çš„æ¡ç›®ï¼Œä»¥ä¾¿åç»­æ­¥éª¤ä¸å†å¤„ç†
            if [ -f deleted-images.txt ]; then
              while IFS= read -r del_image; do
                sed -i "/|${del_image}$/d" combined-list.txt
              done < combined-list.txt
            fi
          fi

      - name: åŒæ­¥æ‰€æœ‰æ¶æ„é•œåƒæ›´æ–°
        env:
          GHCR_USER: ${{ github.repository_owner }}
        run: |
          echo "===== åŒæ­¥é•œåƒåˆ—è¡¨ ====="
          cat combined-list.txt
          echo "===================="

          while IFS='|' read -r source_image target_image; do
            echo "å¤„ç†é•œåƒ: $target_image (æºé•œåƒ: $source_image)"
            source_image_full="docker://$source_image:latest"
            target_image_base="ghcr.io/$(echo "$GHCR_USER" | tr 'A-Z' 'a-z')/$target_image"
            need_update=false

            # è·å–æºé•œåƒçš„æ¸…å•ï¼ˆmanifestï¼‰
            source_manifest=$(skopeo inspect --raw "$source_image_full")
            source_digest=$(echo "$source_manifest" | jq -r '.digest // empty')

            # æ£€æŸ¥ç›®æ ‡é•œåƒæ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™è·å–å…¶æ¸…å•
            if target_manifest=$(skopeo inspect --raw "docker://$target_image_base:latest" 2>/dev/null); then
              target_digest=$(echo "$target_manifest" | jq -r '.digest // empty')
            else
              target_digest=""
            fi

            # æ¯”è¾ƒæ¸…å• digestï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°
            if [ "$source_digest" != "$target_digest" ]; then
              echo "æ£€æµ‹åˆ°æ¸…å•æ›´æ–°ï¼Œå¼€å§‹å…¨æ¶æ„åŒæ­¥..."
              need_update=true
            else
              echo "æ¸…å•æœªæ›´æ–°ï¼Œè·³è¿‡åŒæ­¥"
              continue # è·³è¿‡å½“å‰é•œåƒï¼Œå¤„ç†ä¸‹ä¸€ä¸ª
            fi

            # è·å–æ‰€æœ‰æ”¯æŒçš„æ¶æ„ï¼ˆå¤„ç†åµŒå¥—æ¸…å•åˆ—è¡¨ï¼‰
            if echo "$source_manifest" | jq -e '.manifests' > /dev/null 2>&1; then
              # å¦‚æœæ˜¯å¤šæ¶æ„æ¸…å•ï¼Œæå–æ‰€æœ‰æœ‰æ•ˆæ¶æ„
              ARCHS=$(echo "$source_manifest" | jq -r '.manifests[].platform.architecture' | sort -u | grep -E 'amd64|arm64|armv7|arm|386|ppc64le|s390x|mips64le')
            else
              # å¦‚æœæ˜¯å•æ¶æ„é•œåƒï¼Œç›´æ¥æå–æ¶æ„
              ARCH=$(echo "$source_manifest" | jq -r '.architecture')
              ARCHS=$( [[ "$ARCH" =~ ^(amd64|arm64|armv7|arm|386|ppc64le|s390x|mips64le)$ ]] && echo "$ARCH" || echo "")
            fi

            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ”¯æŒçš„æ¶æ„ï¼Œåˆ™é»˜è®¤ä½¿ç”¨ amd64
            if [ -z "$ARCHS" ]; then
              echo "âŒ æœªæ‰¾åˆ°æ”¯æŒçš„æ¶æ„ï¼Œä½¿ç”¨é»˜è®¤æ¶æ„ amd64"
              ARCHS="amd64"
            fi

            # å¾ªç¯åŒæ­¥å„æ¶æ„é•œåƒ
            for arch in $ARCHS; do
              echo "â–¸ å¤„ç†æ¶æ„: $arch"
              target_tag="$target_image_base:latest-$arch"

              # è·å–æ¶æ„ç‰¹å®šçš„ digestï¼ˆå¤„ç† arm/armv7 åˆ«åï¼‰
              arch_digest=$(echo "$source_manifest" | jq -r \
                --arg arch "$arch" \
                '.manifests[] | select(.platform.architecture == $arch or (.platform.architecture == "armv7" and $arch == "arm")).digest')

              # å¦‚æœ digest ä¸ºç©ºï¼Œå°è¯•é€šè¿‡å¹³å°æ ‡ç­¾åŒ¹é…ï¼ˆé’ˆå¯¹æŸäº›ç‰¹æ®Šçš„ arm é•œåƒï¼‰
              if [ -z "$arch_digest" ]; then
                arch_digest=$(echo "$source_manifest" | jq -r \
                  --arg arch "$arch" \
                  '.manifests[] | select(.platform.variant? == "v7" and $arch == "arm").digest')
              fi

              # æœ€ç»ˆæ£€æŸ¥ digest æœ‰æ•ˆæ€§
              if [ -z "$arch_digest" ]; then
                echo "âš ï¸ è­¦å‘Šï¼šæ¶æ„ $arch ä¸å­˜åœ¨äºæºé•œåƒä¸­ï¼Œå·²è·³è¿‡"
                continue
              fi

              # æ‹‰å–å¹¶æ¨é€æ¶æ„é•œåƒ
              docker pull --platform "linux/$arch" "$(echo "$source_image_full" | sed 's|docker://||')@$arch_digest"
              docker tag "$(echo "$source_image_full" | sed 's|docker://||')@$arch_digest" "$target_tag"
              docker push "$target_tag"
            done

            # æ›´æ–°å¤šæ¶æ„ manifest åˆ—è¡¨
            echo "ğŸ”„ é‡å»ºå¤šæ¶æ„manifeståˆ—è¡¨..."
            # å°è¯•åˆ é™¤æ—§çš„ manifest åˆ—è¡¨ï¼Œå¿½ç•¥é”™è¯¯
            docker manifest rm "$target_image_base:latest" 2>/dev/null || true
            amend_args=()
            for arch in $ARCHS; do
              amend_args+=(--amend "$target_image_base:latest-$arch")
            done
            # åˆ›å»ºæ–°çš„å¤šæ¶æ„ manifest
            docker manifest create "$target_image_base:latest" "${amend_args[@]}" --insecure
            # æ¨é€æ–°çš„ manifest
            docker manifest push "$target_image_base:latest"

            echo "âœ… åŒæ­¥å®Œæˆ: $target_image_base:latest"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          done < combined-list.txt

      - name: è°ƒè¯• gh api å˜é‡
        run: |
          echo "GHCR_USER: ${{ github.repository_owner }}"
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "é”™è¯¯ï¼šGH_TOKEN ä¸ºç©ºï¼Œè¯·æ£€æŸ¥ä½ çš„ä»“åº“ Secretsï¼"
            exit 1
          else
            echo "GH_TOKEN å­˜åœ¨ã€‚"
          fi

      - name: åˆ é™¤ ghcr.io ä¸Š README æœªåˆ—å‡ºçš„é•œåƒåŒ…
        env:
          GHCR_USER: ${{ github.repository_owner }} # ä»“åº“æ‰€æœ‰è€…
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}     # GitHub Actions é»˜è®¤ token
        run: |
          echo "===== æ£€æŸ¥ ghcr.io ä¸Šæ‰€æœ‰åŒ… ====="
          # è·å– README ä¸­åº”ä¿ç•™çš„é•œåƒå
          cat target-image-list.txt | sort > keep-list.txt

          # æ ¹æ® GHCR_USER æ˜¯ä¸ªäººç”¨æˆ·è¿˜æ˜¯ç»„ç»‡æ¥ç¡®å®š API è·¯å¾„å‰ç¼€
          # è¯·æ ¹æ®ä½ çš„å®é™…æƒ…å†µå–æ¶ˆæ³¨é‡Šæ­£ç¡®çš„è¡Œï¼Œå¹¶æ³¨é‡Šæ‰ä¸æ­£ç¡®çš„è¡Œã€‚
          # é»˜è®¤å‡è®¾ ${{ github.repository_owner }} æ˜¯ä¸€ä¸ªä¸ªäººç”¨æˆ·ï¼š
          API_PATH_PREFIX="users/${GHCR_USER}"
          # å¦‚æœ ${{ github.repository_owner }} æ˜¯ä¸€ä¸ªç»„ç»‡ï¼ˆä¾‹å¦‚ï¼Œå¦‚æœä½ çš„ä»“åº“æ˜¯ my-org/my-repoï¼‰ï¼Œè¯·å–æ¶ˆæ³¨é‡Šä»¥ä¸‹è¡Œå¹¶æ³¨é‡Šä¸Šä¸€è¡Œï¼š
          # API_PATH_PREFIX="orgs/${GHCR_USER}"

          echo "æ­£åœ¨ä» ${API_PATH_PREFIX}/packages è·å–åŒ…åˆ—è¡¨..."
          # æ³¨æ„ï¼šä¸ºäº†è°ƒè¯•ï¼Œæˆ‘ä»¬å°† --verbose è¾“å‡ºé‡å®šå‘åˆ°æ–‡ä»¶ï¼Œå¹¶åœ¨å¤±è´¥æ—¶æ‰“å°å‡ºæ¥ã€‚
          # åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œé€šå¸¸ä¸éœ€è¦ --verbose é€‰é¡¹ã€‚
          if ! gh api \
            -H "Accept: application/vnd.github+json" \
            "${API_PATH_PREFIX}/packages?package_type=container&per_page=100" \
            --verbose > ghcr_packages.json 2> debug_ghcr_packages_list.log; then
            echo "è·å–åŒ…åˆ—è¡¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ–é‡è¯•"
            echo "gh api è°ƒè¯•æ—¥å¿—ï¼ˆè·å–åˆ—è¡¨ï¼‰ï¼š"
            cat debug_ghcr_packages_list.log # è¾“å‡ºè°ƒè¯•æ—¥å¿—
            exit 1
          fi

          # æ£€æŸ¥æ˜¯å¦æˆåŠŸè·å–åˆ°æ•°æ®
          if [ ! -s ghcr_packages.json ] || ! jq empty ghcr_packages.json 2>/dev/null; then
            echo "è·å–åˆ°çš„åŒ…æ•°æ®æ— æ•ˆæˆ–ä¸ºç©º"
            cat ghcr_packages.json
            exit 1
          fi

          # ä» API å“åº”ä¸­æå–åŒ…åå¹¶æ’åº
          jq -r '.[].name' ghcr_packages.json | sort > ghcr-list.txt

          echo "åœ¨ ghcr.io ä¸Šæ‰¾åˆ°çš„åŒ…ï¼š"
          cat ghcr-list.txt
          echo "åº”è¯¥ä¿ç•™çš„åŒ…ï¼š"
          cat keep-list.txt

          # æ‰¾å‡ºéœ€è¦åˆ é™¤çš„åŒ…ï¼ˆghcr.io ä¸Šæœ‰ä½† README æ²¡æœ‰çš„ï¼‰
          # comm -23 è¡¨ç¤ºæ‰¾å‡º ghcr-list.txt ä¸­æœ‰ä½† keep-list.txt ä¸­æ²¡æœ‰çš„è¡Œ
          comm -23 ghcr-list.txt keep-list.txt > to-delete.txt

          if [ -s to-delete.txt ]; then
            echo "éœ€è¦åˆ é™¤çš„åŒ…ï¼š"
            cat to-delete.txt
            while IFS= read -r pkg; do
              echo "æ­£åœ¨åˆ é™¤ ghcr.io ä¸Šçš„åŒ…: $pkg (è·¯å¾„: ${API_PATH_PREFIX}/packages/container/${pkg})"
              # ä½¿ç”¨æ­£ç¡®çš„ API è·¯å¾„åˆ é™¤åŒ…
              # åŒæ ·ä¸ºäº†è°ƒè¯•ï¼Œæ·»åŠ  --verbose é€‰é¡¹
              if ! gh api \
                -X DELETE \
                -H "Accept: application/vnd.github+json" \
                "${API_PATH_PREFIX}/packages/container/${pkg}" \
                --silent \
                --verbose 2>> debug_ghcr_packages_delete.log; then # å°†åˆ é™¤æ“ä½œçš„è°ƒè¯•è¾“å‡ºä¹Ÿè¿½åŠ åˆ°æ—¥å¿—æ–‡ä»¶
                echo "åˆ é™¤ $pkg å¤±è´¥ï¼Œå¯èƒ½æ— æƒé™æˆ–åŒ…ä¸å­˜åœ¨"
                echo "gh api è°ƒè¯•æ—¥å¿—ï¼ˆåˆ é™¤æ“ä½œï¼‰ï¼š"
                cat debug_ghcr_packages_delete.log
              fi
            done < to-delete.txt
          else
            echo "æ— éœ€è¦åˆ é™¤çš„åŒ…"
          fi
