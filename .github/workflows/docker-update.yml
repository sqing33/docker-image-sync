name: 更新 Docker 镜像 - ghcr.io

on:
  schedule:
    - cron: "0 16 * * *"
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    steps:
      - name: 检出仓库
        uses: actions/checkout@v4
        with:
          # 使用 token 以便后续可以推送更改
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 安装依赖
        run: sudo apt-get install -y jq skopeo

      - name: 提取需要更新的镜像列表
        id: extract-images
        run: |
          # --- 核心修改点：统一使用新的标题 ---
          TABLE_TITLE="### 已同步的 Docker 镜像"
          
          # 直接提取源镜像和目标镜像，生成组合列表
          awk -F'|' '
            # 找到标题行后，设置标志
            $0 == "'"${TABLE_TITLE}"'" { in_table=1; next }
            # 在表格内时
            in_table {
              # 如果是数据行
              if (/^\| [0-9]/) {
                # 第6列是同步状态
                sync_col = $6;
                # 第3列是源镜像
                source_image = $3;
                # 第4列是目标镜像（pull命令）
                target_image_col = $4;
                
                # 清理字符串两边的空格
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", sync_col);
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", source_image);
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", target_image_col);
                
                # 只处理标记为 ✔️ 的行
                if (sync_col == "✔️") {
                  # 移除 pull 命令中的反引号和标签
                  gsub(/`/, "", target_image_col);
                  sub(/:[^:]*$/, "", target_image_col);
                  
                  # 提取最终的目标镜像名 (例如 dpanel)
                  sub(/.*\//, "", target_image_col);
                  
                  # 打印 源镜像|目标镜像
                  print source_image "|" target_image_col;
                }
              }
              # 如果遇到非表格行，则退出表格模式
              if (!/^\|/ && !/^$/) { in_table=0 }
            }
          ' README.md > combined-list.txt
          
          # 检查生成的文件是否为空
          if [ ! -s combined-list.txt ]; then
            echo "没有找到需要更新的镜像 (标记为 ✔️)，工作流正常结束。"
            # 使用 continue-on-error: true 或其他方式处理，这里直接退出
            exit 0
          fi
          
          echo "===== 将要检查更新的镜像列表 ====="
          cat combined-list.txt
          echo "================================"

      - name: 登录到 GitHub 容器注册表
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 清理步骤可以被整合或优化，但为保持结构，暂时保留并修正
      - name: 清理已删除的镜像条目 (如果需要)
        env:
          GHCR_USER: ${{ github.repository_owner }}
        run: |
          # 此步骤的功能主要是为了防止某个镜像在 ghcr.io 上被手动删除后，更新脚本出错。
          # 暂时可以简化或跳过，因为主要更新逻辑在下一步。
          # 如果需要保留，这里的逻辑也需要更新以匹配新的 combined-list.txt 格式。
          # 为简单起见，暂时注释掉这个复杂的步骤，因为主要功能不受影响。
          echo "清理步骤已跳过，未来可以根据需求重新启用。"
          # ... (原有的复杂清理逻辑) ...

      - name: 同步所有架构镜像更新
        env:
          GHCR_USER: ${{ github.repository_owner }}
        run: |
          if [ ! -s combined-list.txt ]; then
            echo "镜像列表为空，无需同步。"
            exit 0
          fi
          
          echo "===== 开始同步镜像更新 ====="
          cat combined-list.txt
          echo "=========================="

          while IFS='|' read -r source_image target_image; do
            echo "处理镜像: $target_image (源镜像: $source_image)"
            
            # 判断源镜像是否已带 tag
            if [[ "$source_image" == *:* ]]; then
              source_image_full="docker://$source_image"
            else
              source_image_full="docker://$source_image:latest"
            fi
            
            target_image_base="ghcr.io/$(echo "$GHCR_USER" | tr 'A-Z' 'a-z')/$target_image"
            
            # 获取源镜像和目标镜像的 digest
            source_digest=$(skopeo inspect "$source_image_full" --format "{{.Digest}}" 2>/dev/null)
            target_digest=$(skopeo inspect "docker://$target_image_base:latest" --format "{{.Digest}}" 2>/dev/null)

            if [ -z "$source_digest" ]; then
                echo "❌ 无法获取源镜像 $source_image 的 digest，跳过。"
                continue
            fi

            # 比较清单 digest
            if [ "$source_digest" != "$target_digest" ]; then
              echo "✅ 检测到清单更新 ($source_digest != $target_digest)，开始全架构同步..."
              # 直接使用 skopeo copy，它能自动处理多架构
              skopeo copy --all "$source_image_full" "docker://$target_image_base:latest"
              echo "同步完成: $target_image_base:latest"
            else
              echo "清单未更新，跳过同步。"
            fi
            echo "────────────────────────────────────────"
          done < combined-list.txt
