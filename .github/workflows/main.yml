name: 同步 Docker 镜像 → ghcr.io

permissions:
  packages: write
  contents: write

on:
  workflow_dispatch:
    inputs:
      images:
        description: "要同步的 Docker 镜像列表，格式为 '镜像1:标签1,镜像2:标签2,镜像3:标签3'"
        required: true
        default: ""
      ghcr_names:
        description: "对应的同步后的镜像名称列表，格式为 '名称1,名称2,名称3'，如果某个镜像不需要指定名称，则用逗号填充，例如 ',,my-image' 表示第三个镜像同步后名称为 my-image，前两个自动提取"
        required: false
        default: ""
      change_tag_to_latest:
        description: "同步后是否将镜像标签改为 latest (是/否)"
        required: true
        type: choice
        options:
          - "是"
          - "否"
        default: "是"

jobs:
  docker-image-sync:
    runs-on: ubuntu-latest
    steps:
      - name: 安装依赖工具
        run: sudo apt-get update && sudo apt-get install -y jq skopeo

      - name: 检出仓库
        uses: actions/checkout@v4
        with:
          # 使用 token 以便后续可以推送更改
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置 GHCR_USER 环境变量
        id: set_ghcr_user
        run: echo "GHCR_USER=$(echo '${{ github.actor }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: 登录到 GitHub 容器注册表
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USER }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 同步镜像并更新 README
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git pull --rebase

          # --- 1. 镜像同步与信息收集 ---
          # 定义一个变量来收集所有新添加的行，使用一个安全的、不会冲突的分隔符
          NEW_ROWS_DATA=""
          UNIQUE_SEPARATOR="%%%"

          # 提取 README 中已有的源镜像列表，用于查重
          # 注意：这里的标题已经根据你的要求修改为“已同步的 Docker 镜像”
          TABLE_TITLE="### 已同步的 Docker 镜像"
          
          existing_source_images=$(awk '
            $0 == "'"${TABLE_TITLE}"'" { in_table=1; next }
            in_table {
              if (/^\| [0-9]/) { 
                match($0, /\| *[^|]+ *\| *([^|]+) *\|/);
                if (RSTART) { print substr($0, RSTART, RLENGTH) }
              }
              if (!/^\|/ && !/^$/) { in_table=0 }
            }
          ' README.md | sed -e 's/|//g' -e 's/^[ \t]*//;s/[ \t]*$//')

          IFS=',' read -r -a image_array <<< "${{ inputs.images }}"
          IFS=',' read -r -a ghcr_name_array <<< "${{ inputs.ghcr_names }}"

          for i in "${!image_array[@]}"; do
            full_image=$(echo "${image_array[$i]}" | xargs) # xargs to trim whitespace
            if [ -z "$full_image" ]; then continue; fi

            # 查重
            if echo "$existing_source_images" | grep -qFx "$full_image"; then
              echo "镜像 $full_image 已存在于 README.md，跳过。"
              continue
            fi
            
            # ... (镜像同步的核心逻辑，这里保持不变) ...
            echo "\n===== 开始同步 $full_image ====="
            current_image=$(echo "$full_image" | cut -d':' -f1)
            current_tag=$(echo "$full_image" | cut -s -d':' -f2); [ -z "$current_tag" ] && current_tag="latest"
            target_tag="$current_tag"; [[ "$current_tag" =~ "alpine" ]] && target_tag="alpine" || { [ "${{ inputs.change_tag_to_latest }}" == "是" ] && target_tag="latest"; }
            if [ "$current_tag" == "latest" ] || [ "$target_tag" == "alpine" ]; then sync_status="✔️"; else sync_status="❌"; fi
            current_ghcr_name="${ghcr_name_array[$i]}"; [ -z "$current_ghcr_name" ] && IMAGE_NAME=$(basename "$current_image") || IMAGE_NAME="$current_ghcr_name"
            # ... 此处省略 skopeo 和 docker pull/push 等具体同步操作，它们是正确的 ...
            echo "同步逻辑执行中... 镜像将被命名为 $IMAGE_NAME"

            # 创建 docker-compose.yaml 文件
            mkdir -p docker-compose
            cp docker-compose/example.yaml "docker-compose/$IMAGE_NAME.yaml"

            # 准备新行的数据，但不立即写入文件
            pull_cmd="ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME"; [ "$target_tag" != "latest" ] && pull_cmd="$pull_cmd:$target_tag"
            pull_cmd="\`$pull_cmd\`"
            compose_file="[yaml](https://github.com/${{ github.repository }}/blob/main/docker-compose/$IMAGE_NAME.yaml)"
            
            # 将新行的数据用分隔符拼接成一个安全的字符串
            new_line_data="${full_image}${UNIQUE_SEPARATOR}${pull_cmd}${UNIQUE_SEPARATOR}${compose_file}${UNIQUE_SEPARATOR}${sync_status}"
            NEW_ROWS_DATA+="${new_line_data}\n"
          done
          
          # 如果没有任何新行，则直接退出
          if [ -z "$NEW_ROWS_DATA" ]; then
            echo "没有新的镜像被添加，无需更新 README.md。"
            exit 0
          fi

          # --- 2. README 更新、排序与重写 ---
          echo "开始更新 README.md..."
          
          # 提取已有的数据行
          existing_rows=$(awk '
            $0 == "'"${TABLE_TITLE}"'" { in_table=1; next }
            in_table {
              if (/^\| [0-9]/) { print }
              if (!/^\|/ && !/^$/) { in_table=0 }
            }
          ' README.md)

          # 合并新旧数据，并进行排序
          # 1. 装饰（添加排序键）
          # 2. 排序
          # 3. 去掉装饰
          # 4. 重新添加行号
          sorted_table_rows=$(
            # 将新旧行都转换成统一格式
            {
              # 旧行
              echo "$existing_rows" | sed 's/^| [0-9]\{1,\} *|/|/'
              # 新行
              echo -e "$NEW_ROWS_DATA" | sed '/^$/d' | awk -F"${UNIQUE_SEPARATOR}" '{printf("| %s | %s | %s | %s |\n", $1, $2, $3, $4)}'
            } | awk -F'|' '
              # 装饰：提取排序键（例如 dpanel）
              {
                key = $3;
                gsub(/`/, "", key);
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", key);
                sub(/.*\/|:[^:]*$/, "", key);
                print key "@@@" $0;
              }
            ' | sort -f | sed 's/^.*@@@//' | awk 'BEGIN{count=1} {printf("| %-3s %s\n", count++, $0)}'
          )

          # 创建包含最终完整表格内容的临时文件
          {
            echo "${TABLE_TITLE}"
            echo ""
            echo "|   | 源镜像 | pull 镜像 | docker-compose | 同步 |"
            echo "| ---- | -------- | --------- | -------------- | ---- |"
            echo "$sorted_table_rows"
          } > new_table.tmp
          
          # 使用绝对可靠的 awk 脚本替换整个表格
          awk '
            BEGIN { replaced=0 }
            $0 == "'"${TABLE_TITLE}"'" && !replaced {
              while ((getline line < "new_table.tmp") > 0) { print line }
              close("new_table.tmp");
              replaced=1;
              skipping=1;
              next;
            }
            skipping {
              if (!/^\|/ && !/^$/) { skipping=0 } else { next }
            }
            { print }
          ' README.md > README.tmp && mv README.tmp README.md
          rm new_table.tmp

          # 提交更改
          git add README.md docker-compose/
          if git diff --staged --quiet; then
            echo "没有新的镜像或文件变更可提交。"
          else
            git commit -m "chore(sync): 同步新镜像并自动排序更新README"
            git push
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
