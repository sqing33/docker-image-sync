name: 将 Docker 镜像同步到 ghcr.io

permissions:
  packages: write
  contents: write

on:
  workflow_dispatch:
    inputs:
      images:
        description: "要同步的 Docker 镜像列表，格式为 '镜像1:标签1,镜像2:标签2,镜像3:标签3'"
        required: true
        default: ""
      ghcr_names:
        description: "对应的同步后的镜像名称列表，格式为 '名称1,名称2,名称3'，如果某个镜像不需要指定名称，则用逗号填充，例如 ',,my-image' 表示第三个镜像同步后名称为 my-image，前两个自动提取"
        required: false
        default: ""
      change_tag_to_latest:
        description: "同步后是否将镜像标签改为 latest (是/否)"
        required: true
        type: choice
        options:
          - "是"
          - "否"
        default: "是"

jobs:
  docker-image-sync:
    runs-on: ubuntu-latest
    steps:
      - name: 安装依赖工具
        run: sudo apt-get update && sudo apt-get install -y jq skopeo

      - name: 检出仓库
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置 GHCR_USER 环境变量
        id: set_ghcr_user
        run: echo "GHCR_USER=$(echo '${{ github.actor }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: 登录到 GitHub 容器注册表
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USER }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 顺序同步所有镜像并准备 README 更新
        id: sync_and_prep
        run: |
          # 用于收集新添加的表格行
          new_rows=""
          
          IFS=',' read -r -a image_array <<< "${{ inputs.images }}"
          IFS=',' read -r -a ghcr_name_array <<< "${{ inputs.ghcr_names }}"

          # 提取 README 中已有的源镜像列表，用于查重
          # 注意：这里的标题已经根据你的要求修改
          existing_images=$(awk '
            /^### 已同步的 Docker 镜像/ { in_table=1; next }
            in_table {
              if (/^\| [0-9]/) { 
                # 提取第2列（源镜像），并进行清理
                img = $3;
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", img);
                print img;
              }
              if (!/^\|/ && !/^$/) { in_table=0 }
            }
          ' README.md)

          for i in "${!image_array[@]}"; do
            full_image="${image_array[$i]}"
            
            if [ -z "$full_image" ]; then
              echo "警告：第 $((i+1)) 个镜像名称为空，已跳过。"
              continue
            fi
            
            # 检查镜像是否已存在
            # 清理输入镜像名以便和列表比较
            check_image_name=$(echo "$full_image" | xargs)
            if echo "$existing_images" | grep -qFx "$check_image_name"; then
              echo "镜像 $full_image 已存在于 README.md，跳过同步和更新。"
              continue
            fi

            current_image=$(echo "$full_image" | cut -d':' -f1)
            current_tag=$(echo "$full_image" | cut -s -d':' -f2)
            if [ -z "$current_tag" ]; then
              current_tag="latest"
            fi
            current_ghcr_name="${ghcr_name_array[$i]}"

            target_tag="$current_tag"
            if [[ "$current_tag" =~ "alpine" ]]; then
              target_tag="alpine"
            elif [ "${{ inputs.change_tag_to_latest }}" == "是" ]; then
              target_tag="latest"
            fi

            if [ "$current_tag" == "latest" ] || [ "$target_tag" == "alpine" ]; then
              sync_status="✔️"
            else
              sync_status="❌"
            fi

            echo "\n===== 开始同步第 $((i+1)) 个镜像: $current_image:$current_tag ====="

            # 省略的同步逻辑...（此处为演示，实际同步逻辑不变）
            # 设置 IMAGE_NAME
            if [ -z "$current_ghcr_name" ]; then
              IMAGE_NAME=$(basename "$current_image")
            else
              IMAGE_NAME="$current_ghcr_name"
            fi
            echo "同步逻辑执行中... 镜像将被命名为 $IMAGE_NAME"
            # ... docker pull, tag, push 等操作 ...

            # 创建 docker-compose.yaml 文件
            mkdir -p docker-compose
            cp docker-compose/example.yaml docker-compose/$IMAGE_NAME.yaml
            
            # 如果是新镜像，则生成其表格行并暂存
            echo "添加新镜像 $full_image 到待更新列表"
            pull_cmd="ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME:$target_tag"
            if [[ "$target_tag" == "latest" ]]; then
              pull_cmd="${pull_cmd%:latest}"
            fi
            pull_cmd="\`$pull_cmd\`"
            compose_file="[yaml](https://github.com/${{ github.repository }}/blob/main/docker-compose/$IMAGE_NAME.yaml)"
            
            # 使用 printf 生成格式统一的行，注意序号留空，后续统一处理
            # 使用制表符作为临时分隔符，便于后续处理
            new_row_data=$(printf "PLACEHOLDER\t%s\t%s\t%s\t%s" "$full_image" "$pull_cmd" "$compose_file" "$sync_status")
            # 将所有新行用换行符分隔追加到变量中
            if [ -z "$new_rows" ]; then
              new_rows="$new_row_data"
            else
              new_rows="$new_rows\n$new_row_data"
            fi
            echo "===== 同步完成: $current_image:$current_tag =====\n"
          done
          
          # 将收集到的新行输出到 action output，以便下一步使用
          # 使用特殊字符替换换行符，以便在步骤间传递
          echo "new_rows<<EOF" >> $GITHUB_OUTPUT
          echo -e "$new_rows" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: 更新 README.md 并自动排序
        if: steps.sync_and_prep.outputs.new_rows != ''
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git pull --rebase

          # 提取 README 中已有的数据行，注意不包含序号
          existing_rows=$(awk '
            /^### 已同步的 Docker 镜像/ { in_table=1; next }
            in_table {
              if (/^\| [0-9]/) { 
                # 打印从第2列到最后一列的所有内容
                match($0, /\| [0-9]+ *\|(.*)\|/);
                print substr($0, RSTART + RLENGTH - length(substr($0, RSTART, RLENGTH)) + 1, length(substr($0, RSTART, RLENGTH)) - 2);
              }
              if (!/^\|/ && !/^$/) { in_table=0 }
            }
          ' README.md)

          # 将上一步收集的新行转换回带换行符的格式
          new_rows="${{ steps.sync_and_prep.outputs.new_rows }}"
          # 将暂存的新行中的占位符和制表符转换成 Markdown 表格的列
          new_rows_formatted=$(echo -e "$new_rows" | awk -F'\t' '{printf(" %-30s | %-48s | %-100s | %-3s ", $2, $3, $4, $5)}' )

          # 合并新旧数据行
          # 使用 echo -e 处理换行符，并用 grep 去除可能产生的空行
          combined_rows=$(echo -e "${existing_rows}\n${new_rows_formatted}" | grep -v '^$')
          
          # --- 核心排序逻辑 ---
          # 提取 pull 命令中的镜像名作为排序键，进行排序
          # sort -t'|' -k2 表示按第2列（pull 镜像）排序
          sorted_rows=$(echo "$combined_rows" | \
            awk -F'|' '{
              gsub(/`/, "", $2); 
              gsub(/^[[:space:]]+|[[:space:]]+$/, "", $2); 
              split($2, parts, "/"); 
              key=parts[3]; 
              print key "@@@" $0
            }' | \
            sort -f | \
            cut -d'@' -f4-
          )
          
          # 重新生成带序号的完整表格
          final_table_content=$(echo "$sorted_rows" | awk 'BEGIN{count=1} {printf "| %-3s |%s|\n", count++, $0}')

          # 准备写入文件的完整内容
          {
            echo "### 已同步的 Docker 镜像"
            echo ""
            echo "|   | 源镜像 | pull 镜像 | docker-compose | 同步 |"
            echo "| ---- | -------- | --------- | -------------- | ---- |"
            echo "$final_table_content"
          } > new_table.tmp

          # 使用健壮的 awk 脚本替换整个表格
          awk '
            BEGIN { skipping=0 }
            /^### 已同步的 Docker 镜像/ {
              while ((getline line < "new_table.tmp") > 0) { print line }
              close("new_table.tmp");
              skipping=1;
              next
            }
            skipping==1 {
              if (!/^\|/ && !/^$/) {
                skipping=0;
                print;
              }
              next;
            }
            { print }
          ' README.md > README.tmp && mv README.tmp README.md
          rm new_table.tmp

          # 提交更改
          git add README.md docker-compose/
          if git diff --staged --quiet; then
            echo "没有新的镜像或文件变更可提交。"
          else
            git commit -m "chore: 同步新镜像并更新README"
            git push
          fi
