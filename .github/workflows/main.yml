name: å°† Docker é•œåƒåŒæ­¥åˆ° ghcr.io

permissions:
  packages: write
  contents: write

on:
  workflow_dispatch:
    inputs:
      images:
        description: "è¦åŒæ­¥çš„ Docker é•œåƒåˆ—è¡¨ï¼Œæ ¼å¼ä¸º 'é•œåƒ1:æ ‡ç­¾1,é•œåƒ2:æ ‡ç­¾2,é•œåƒ3:æ ‡ç­¾3'"
        required: true
        default: ""
      ghcr_names:
        description: "å¯¹åº”çš„åŒæ­¥åçš„é•œåƒåç§°åˆ—è¡¨ï¼Œæ ¼å¼ä¸º 'åç§°1,åç§°2,åç§°3'ï¼Œå¦‚æœæŸä¸ªé•œåƒä¸éœ€è¦æŒ‡å®šåç§°ï¼Œåˆ™ç”¨é€—å·å¡«å……ï¼Œä¾‹å¦‚ ',,my-image' è¡¨ç¤ºç¬¬ä¸‰ä¸ªé•œåƒåŒæ­¥ååç§°ä¸º my-imageï¼Œå‰ä¸¤ä¸ªè‡ªåŠ¨æå–"
        required: false
        default: ""
      change_tag_to_latest:
        description: "åŒæ­¥åæ˜¯å¦å°†é•œåƒæ ‡ç­¾æ”¹ä¸º latest (æ˜¯/å¦)"
        required: true
        type: choice
        options:
          - "æ˜¯"
          - "å¦"
        default: "æ˜¯"

jobs:
  docker-image-sync:
    runs-on: ubuntu-latest
    steps:
      - name: å®‰è£…ä¾èµ–å·¥å…·
        run: sudo apt-get update && sudo apt-get install -y jq skopeo

      - name: æ£€å‡ºä»“åº“
        uses: actions/checkout@v4

      - name: è®¾ç½® GHCR_USER ç¯å¢ƒå˜é‡
        id: set_ghcr_user
        run: echo "GHCR_USER=$(echo '${{ github.actor }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: ç™»å½•åˆ° GitHub å®¹å™¨æ³¨å†Œè¡¨
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USER }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: è®¾ç½® Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: é¡ºåºåŒæ­¥æ‰€æœ‰é•œåƒ
        run: |
          IFS=',' read -r -a image_array <<< "${{ inputs.images }}"
          IFS=',' read -r -a ghcr_name_array <<< "${{ inputs.ghcr_names }}"
          for i in "${!image_array[@]}"; do
            full_image_raw="${image_array[$i]}"
            full_image_cleaned=$(echo "$full_image_raw" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [ -z "$full_image_cleaned" ]; then
              echo "è­¦å‘Šï¼šç¬¬ $((i+1)) ä¸ªåŸå§‹é•œåƒæ¡ç›® '${full_image_raw}' åœ¨æ¸…ç†å‰åç©ºæ ¼åä¸ºç©ºï¼Œå·²è·³è¿‡ã€‚"
              continue
            fi
            current_image_from_input=$(echo "$full_image_cleaned" | cut -d':' -f1)
            current_tag_from_input=$(echo "$full_image_cleaned" | cut -s -d':' -f2)
            if [ -z "$current_image_from_input" ]; then
              echo "è­¦å‘Šï¼šç¬¬ $((i+1)) ä¸ªé•œåƒ '${full_image_cleaned}' åç§°éƒ¨åˆ†ä¸ºç©ºï¼Œå·²è·³è¿‡ã€‚"
              continue
            fi
            effective_input_tag="$current_tag_from_input"
            if [ -z "$effective_input_tag" ]; then
              effective_input_tag="latest"
            fi
            
            full_image_for_sync="$current_image_from_input:$effective_input_tag"
            key_for_readme_check="$current_image_from_input"
            if [ "$effective_input_tag" != "latest" ]; then
              key_for_readme_check="$current_image_from_input:$effective_input_tag"
            fi
            current_ghcr_name="${ghcr_name_array[$i]}"
            target_tag="$effective_input_tag"
            if [[ "$effective_input_tag" =~ "alpine" ]]; then
               target_tag="alpine"
            elif [ "${{ inputs.change_tag_to_latest }}" == "æ˜¯" ]; then
               target_tag="latest"
            fi
            sync_status="âŒ"
            if [ "$effective_input_tag" == "latest" ] || [[ "$target_tag" == "alpine" ]]; then
               sync_status="âœ”ï¸"
            elif [ "${{ inputs.change_tag_to_latest }}" == "æ˜¯" ] && [ "$target_tag" == "latest" ]; then
               sync_status="âœ”ï¸"
            fi
            echo "\n===== å¼€å§‹åŒæ­¥ç¬¬ $((i+1)) ä¸ªé•œåƒ: $full_image_for_sync (åŸå§‹è¾“å…¥: '$full_image_raw', ç”¨äºæŸ¥é‡é”®: '$key_for_readme_check', ç›®æ ‡GHCRæ ‡ç­¾: '$target_tag') ====="
            RAW_MANIFEST=$(skopeo inspect --raw "docker://$full_image_for_sync")
            if echo "$RAW_MANIFEST" | jq -e '.manifests' > /dev/null 2>&1; then
              ARCHS=$(echo "$RAW_MANIFEST" | jq -r '.manifests[].platform.architecture' | sort -u | grep -E 'amd64|arm64|arm|386|ppc64le|s390x|mips64le' | tr '\n' ',' | sed 's/,$//')
            else
              ARCH=$(echo "$RAW_MANIFEST" | jq -r '.architecture')
              ARCHS=$( [[ "$ARCH" =~ ^(amd64|arm64|arm|386|ppc64le|s390x|mips64le)$ ]] && echo "$ARCH" || echo "")
            fi
            if [ -z "$ARCHS" ]; then
              echo "âŒ æœªæ‰¾åˆ°æ”¯æŒçš„æ¶æ„ï¼Œä½¿ç”¨é»˜è®¤æ¶æ„ amd64"
              ARCHS="amd64"
            fi
            ARCHS_STR=$(echo "$ARCHS" | tr ',' ' ')
            echo "æœ‰æ•ˆæ¶æ„: $ARCHS_STR"
            if [ -z "$current_ghcr_name" ]; then
              IMAGE_NAME=$(basename "$current_image_from_input")
            else
              IMAGE_NAME="$current_ghcr_name"
            fi
            declare -a VALID_ARCHS=()
            
            TEMP_MANIFEST_LIST_NAME="ghcr.io/${GHCR_USER}/$IMAGE_NAME:${target_tag}-temp-manifest" # Use GHCR_USER from env

            for arch in $ARCHS_STR; do
              echo "ğŸ”„ æ­£åœ¨æ£€æŸ¥å’ŒåŒæ­¥ $arch æ¶æ„..."
              echo "$GITHUB_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
              if docker pull --platform "linux/$arch" "$full_image_for_sync"; then
                echo "âœ”ï¸ $arch æ¶æ„æ‹‰å–æˆåŠŸ"
                VALID_ARCHS+=("$arch")
                docker tag "$full_image_for_sync" \
                  "ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag-$arch"
                docker push "ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag-$arch"
                
                if [ ${#VALID_ARCHS[@]} -eq 1 ]; then 
                    docker manifest create "$TEMP_MANIFEST_LIST_NAME" \
                        "ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag-$arch" --insecure
                else 
                    docker manifest annotate "$TEMP_MANIFEST_LIST_NAME" \
                        "ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag-$arch" --arch "$arch"
                    docker manifest create "$TEMP_MANIFEST_LIST_NAME" \
                        --amend "ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag-$arch" --insecure
                fi
              else
                echo "âš ï¸ è­¦å‘Šï¼šæ‹‰å– $arch æ¶æ„é•œåƒå¤±è´¥ï¼Œå·²è·³è¿‡"
              fi
              docker rmi "$full_image_for_sync" >/dev/null 2>&1 || true 
              echo "----------------------------------------"
            done

            if [ ${#VALID_ARCHS[@]} -eq 0 ]; then
              echo "âŒ æ‰€æœ‰æŒ‡å®šæ¶æ„å‡ä¸å­˜åœ¨æˆ–æ‹‰å–å¤±è´¥ï¼Œåœæ­¢åŒæ­¥æ­¤é•œåƒ"
              continue
            fi

            echo "ğŸ› ï¸ åˆ›å»ºå¹¶æ¨é€æœ€ç»ˆçš„å¤šæ¶æ„æ¸…å• (ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag)..."
            docker manifest push "$TEMP_MANIFEST_LIST_NAME" --purge 
             echo "Retagging manifest using skopeo..."
             skopeo copy --all "docker://$TEMP_MANIFEST_LIST_NAME" "docker://ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag"

            for arch_cleanup in ${VALID_ARCHS[@]}; do
              docker rmi "ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag-$arch_cleanup" >/dev/null 2>&1 || true
            done
            docker manifest rm "$TEMP_MANIFEST_LIST_NAME" >/dev/null 2>&1 || true 

            mkdir -p docker-compose
            compose_file_name="$IMAGE_NAME" 
            if [ -f "docker-compose/example.yaml" ]; then
              cp docker-compose/example.yaml "docker-compose/$compose_file_name.yaml"
              git config --global user.name "GitHub Actions"
              git config --global user.email "actions@github.com"
              git add "docker-compose/$compose_file_name.yaml"
              if ! git diff --staged --quiet "docker-compose/$compose_file_name.yaml"; then
                git commit -m "æ·»åŠ /æ›´æ–° $compose_file_name.yaml æ–‡ä»¶ (é•œåƒ: $IMAGE_NAME)" || echo "No changes to commit for compose file, or commit failed."
                # Consider moving git pull/push outside the loop for efficiency
                git pull --rebase origin main 
                git push origin main
              else
                echo "No changes detected for docker-compose/$compose_file_name.yaml"
              fi
            else
              echo "è­¦å‘Š: docker-compose/example.yaml æœªæ‰¾åˆ°ï¼Œè·³è¿‡åˆ›å»º $compose_file_name.yaml"
            fi
            
            temp_readme_keys_file=$(mktemp)
            awk -F '|' '
                BEGIN { capture_block = 0 }
                /^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/ { capture_block = 1; next }
                capture_block && /^\| *[0-9]+ *\|/ {
                    if (match($0, /^\|[^|]*\|([^|]*)\|/, col_array)) {
                        source_img_raw = col_array[1];
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", source_img_raw);
                        if (source_img_raw != "") {
                            img_name_part = source_img_raw;
                            img_tag_part = "";
                            if (index(source_img_raw, ":")) {
                                img_name_part = substr(source_img_raw, 1, index(source_img_raw, ":") - 1);
                                img_tag_part = substr(source_img_raw, index(source_img_raw, ":") + 1);
                            }
                            if (img_tag_part == "latest" || img_tag_part == "") {
                                print img_name_part;
                            } else {
                                print source_img_raw;
                            }
                        }
                    }
                }
                capture_block && (!/^\|/ && !/^[[:space:]]*$/ && !/^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/) { capture_block = 0 }
            ' README.md > "$temp_readme_keys_file"
            existing_sources_keys=$(<"$temp_readme_keys_file")
            rm "$temp_readme_keys_file"

            already_exists=false
            if echo "${existing_sources_keys}" | grep -qFx "$key_for_readme_check"; then
              already_exists=true
            fi

            if $already_exists; then
              echo "é•œåƒ '$key_for_readme_check' å·²å­˜åœ¨äº README è¡¨æ ¼ï¼Œè·³è¿‡æ·»åŠ ã€‚"
            else
              echo "æ·»åŠ æ–°é•œåƒ '$key_for_readme_check' åˆ° README"
              
              last_h3_linenum=$(grep -n "^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ" README.md | tail -n 1 | cut -d: -f1)
              data_lines=""
              if [ -n "$last_h3_linenum" ]; then
                  data_lines=$(tail -n "+$last_h3_linenum" README.md | awk '/^\| *[0-9]+ *\|[^|]*\|[^|]*\|[^|]*\|[^|]*\|/')
              fi

              count=0
              if [ -n "$data_lines" ]; then
                count=$(echo "$data_lines" | wc -l)
              fi
              new_count=$((count + 1))
              
              display_image_name_for_readme="$current_image_from_input"
              if [ "$effective_input_tag" != "latest" ]; then
                display_image_name_for_readme="$current_image_from_input:$effective_input_tag"
              fi
              
              pull_cmd_val="ghcr.nju.edu.cn/${GHCR_USER}/$IMAGE_NAME" # Use GHCR_USER from env
              if [ "$target_tag" != "latest" ]; then
                pull_cmd_val="$pull_cmd_val:$target_tag"
              fi
              pull_cmd_markdown="\`$pull_cmd_val\`"
              compose_file_markdown="[yaml](https://github.com/${{ github.repository }}/blob/main/docker-compose/$compose_file_name.yaml)"
              
              printf -v new_row "| %-3s | %-30s | %-48s | %-100s | %-3s |\n" "$new_count" "$display_image_name_for_readme" "$pull_cmd_markdown" "$compose_file_markdown" "$sync_status"
              
              new_table_content_file=$(mktemp)
              {
                echo "### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ"
                echo ""
                echo "|   | æºé•œåƒ | pull é•œåƒ | docker-compose | åŒæ­¥ |"
                echo "| ---- | -------- | --------- | -------------- | ---- |"
                if [ -n "$data_lines" ]; then
                    echo "$data_lines" 
                fi
                echo -n "$new_row" 
              } > "$new_table_content_file"
              
              # AWK script content stored in a variable
              awk_script_content=$(printf '%s\n' \
              'BEGIN { table_replaced = 0 }' \
              '/^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/ {' \
              '    if (!table_replaced) {' \
              '        while ((getline line < new_content_filename_var) > 0) { print line }' \
              '        close(new_content_filename_var)' \
              '        table_replaced = 1' \
              '        while (getline > 0) {' \
              '            if (line !~ /^\|/ && line !~ /^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/ && line !~ /^[[:space:]]*$/) {' \
              '                print line' \
              '                break' \
              '            }' \
              '        }' \
              '    }' \
              '    next' \
              '}' \
              '{ print }')

              awk_script_file=$(mktemp)
              echo "$awk_script_content" > "$awk_script_file"
              
              awk -v new_content_filename_var="$new_table_content_file" -f "$awk_script_file" README.md > README.tmp && mv README.tmp README.md
              
              rm "$new_table_content_file" "$awk_script_file"
              
              git config --global user.name "GitHub Actions"
              git config --global user.email "actions@github.com"
              git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"
              git add README.md
              if ! git diff --staged --quiet README.md; then
                  git commit -m "æ›´æ–°README.mdï¼Œæ·»åŠ æ–°çš„é•œåƒè¡¨æ ¼æ¡ç›®: $display_image_name_for_readme" || echo "README commit failed or no changes."
                  # Consider moving git pull/push outside the loop for efficiency
                  git pull --rebase origin main 
                  git push origin main
              else
                  echo "No changes detected for README.md"
              fi
            fi
            echo "===== åŒæ­¥å®Œæˆ: $full_image_for_sync (æ¨é€åˆ° ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag) =====\n" # Use GHCR_USER from env
          done
          docker image prune -a --force
        env:
          # GITHUB_TOKEN is automatically available to the workflow script
          # GHCR_USER is set in a previous step and available in the environment
          # No need to redefine GITHUB_TOKEN here unless you intend to override the default one,
          # but the ${{ secrets.GITHUB_TOKEN }} is correctly used directly where needed.
          # If you were using it as `env.GITHUB_TOKEN` in the script, then defining it here would be necessary.
          # For `docker login`, it uses `${{ secrets.GITHUB_TOKEN }}` directly.
          # For `git remote set-url`, I've put `${GITHUB_TOKEN}` which implies it's set in the shell env.
          # The `secrets.GITHUB_TOKEN` is passed to `docker login` action.
          # For the `git` commands in the script, we need to ensure `GITHUB_TOKEN` is available.
          # Setting it explicitly in the `env` block for the step ensures it's available.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
