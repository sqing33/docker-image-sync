name: å°† Docker é•œåƒåŒæ­¥åˆ° ghcr.io

permissions:
  packages: write
  contents: write

on:
  workflow_dispatch:
    inputs:
      images:
        description: "è¦åŒæ­¥çš„ Docker é•œåƒåˆ—è¡¨ï¼Œæ ¼å¼ä¸º 'é•œåƒ1:æ ‡ç­¾1,é•œåƒ2:æ ‡ç­¾2,é•œåƒ3:æ ‡ç­¾3'"
        required: true
        default: ""
      ghcr_names:
        description: "å¯¹åº”çš„åŒæ­¥åçš„é•œåƒåç§°åˆ—è¡¨ï¼Œæ ¼å¼ä¸º 'åç§°1,åç§°2,åç§°3'ï¼Œå¦‚æœæŸä¸ªé•œåƒä¸éœ€è¦æŒ‡å®šåç§°ï¼Œåˆ™ç”¨é€—å·å¡«å……ï¼Œä¾‹å¦‚ ',,my-image' è¡¨ç¤ºç¬¬ä¸‰ä¸ªé•œåƒåŒæ­¥ååç§°ä¸º my-imageï¼Œå‰ä¸¤ä¸ªè‡ªåŠ¨æå–"
        required: false
        default: ""
      change_tag_to_latest:
        description: "åŒæ­¥åæ˜¯å¦å°†é•œåƒæ ‡ç­¾æ”¹ä¸º latest (æ˜¯/å¦)"
        required: true
        type: choice
        options:
          - "æ˜¯"
          - "å¦"
        default: "æ˜¯"

jobs:
  docker-image-sync:
    runs-on: ubuntu-latest
    steps:
      - name: å®‰è£…ä¾èµ–å·¥å…·
        run: sudo apt-get update && sudo apt-get install -y jq skopeo

      - name: æ£€å‡ºä»“åº“
        uses: actions/checkout@v4

      - name: è®¾ç½® GHCR_USER ç¯å¢ƒå˜é‡
        id: set_ghcr_user
        run: echo "GHCR_USER=$(echo '${{ github.actor }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: ç™»å½•åˆ° GitHub å®¹å™¨æ³¨å†Œè¡¨
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USER }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: è®¾ç½® Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: é¡ºåºåŒæ­¥æ‰€æœ‰é•œåƒ
        run: |
          IFS=',' read -r -a image_array <<< "${{ inputs.images }}"
          IFS=',' read -r -a ghcr_name_array <<< "${{ inputs.ghcr_names }}"

          for i in "${!image_array[@]}"; do
            full_image_raw="${image_array[$i]}"
            # æ¸…ç† full_image_raw å‰åçš„ç©ºæ ¼
            full_image=$(echo "$full_image_raw" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

            # å¦‚æœæ¸…ç†å full_image ä¸ºç©ºå­—ç¬¦ä¸² (ä¾‹å¦‚è¾“å…¥æ˜¯ ",," æˆ–è€…åªæœ‰é€—å·ä¸”æ²¡æœ‰æœ‰æ•ˆå­—ç¬¦)
            if [ -z "$full_image" ]; then
              echo "è­¦å‘Šï¼šç¬¬ $((i+1)) ä¸ªåŸå§‹é•œåƒæ¡ç›® '${full_image_raw}' åœ¨æ¸…ç†å‰åç©ºæ ¼åä¸ºç©ºï¼Œå·²è·³è¿‡ã€‚"
              continue
            fi

            current_image=$(echo "$full_image" | cut -d':' -f1)
            current_tag=$(echo "$full_image" | cut -s -d':' -f2)

            # å¦‚æœ current_image ä¸ºç©º (ä¾‹å¦‚ full_image æ˜¯ ":tag" æˆ–è€…æ¸…ç†ååªå‰©å†’å·)
            if [ -z "$current_image" ]; then
              echo "è­¦å‘Šï¼šç¬¬ $((i+1)) ä¸ªé•œåƒ '${full_image_raw}' åç§°éƒ¨åˆ†ä¸ºç©ºï¼Œå·²è·³è¿‡ã€‚"
              continue
            fi

            # å¦‚æœæ ‡ç­¾ä¸ºç©ºï¼Œé»˜è®¤ä¸º latestï¼Œå¹¶æ›´æ–° full_image ä»¥åŒ…å«æ­¤æ ‡ç­¾ç”¨äºåç»­æ¯”è¾ƒ
            if [ -z "$current_tag" ]; then
              current_tag="latest"
              # åªæœ‰å½“åŸå§‹ full_image (æ¸…ç†ç©ºæ ¼å) ç¡®å®æ²¡æœ‰å†’å·ï¼Œæˆ–è€…ä»¥å†’å·ç»“å°¾æ—¶ï¼Œæ‰æ›´æ–° full_image
              if ! echo "$full_image" | grep -q ':' || [[ "$full_image" == *":" ]]; then
                full_image="$current_image:$current_tag"
              fi
            fi
            
            current_ghcr_name="${ghcr_name_array[$i]}"

            target_tag="$current_tag"
            if [[ "$current_tag" =~ "alpine" ]]; then
              target_tag="alpine" # ä¿ç•™ alpine æ ‡ç­¾
            elif [ "${{ inputs.change_tag_to_latest }}" == "æ˜¯" ]; then
              target_tag="latest"
            fi

            # sync_status çš„åˆ¤æ–­é€»è¾‘ä¿æŒä¸å˜
            if [ "$current_tag" == "latest" ] || [ "$target_tag" == "alpine" ]; then
               sync_status="âœ”ï¸"
            else
               sync_status="âŒ"
            fi

            # if [ -z "$current_image" ]; then # è¿™ä¸ªæ£€æŸ¥å·²æå‰
            #   echo "è­¦å‘Šï¼šç¬¬ $((i+1)) ä¸ªé•œåƒåç§°ä¸ºç©ºï¼Œå·²è·³è¿‡ã€‚"
            #   continue
            # fi

            echo "\n===== å¼€å§‹åŒæ­¥ç¬¬ $((i+1)) ä¸ªé•œåƒ: $full_image (åŸå§‹è¾“å…¥éƒ¨åˆ†: $full_image_raw) ====="

            # è‡ªåŠ¨è·å–æ‰€æœ‰å¯ç”¨æ¶æ„ (æ­¤éƒ¨åˆ†é€»è¾‘ä¸å˜)
            RAW_MANIFEST=$(skopeo inspect --raw "docker://$current_image:$current_tag") # æ³¨æ„ï¼šè¿™é‡Œç”¨ current_image å’Œ current_tag (å¯èƒ½æ˜¯åŸå§‹çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯é»˜è®¤çš„ latest)
            if echo "$RAW_MANIFEST" | jq -e '.manifests' > /dev/null 2>&1; then
              ARCHS=$(echo "$RAW_MANIFEST" | jq -r '.manifests[].platform.architecture' | sort -u | grep -E 'amd64|arm64|arm|386|ppc64le|s390x|mips64le' | tr '\n' ',' | sed 's/,$//')
            else
              ARCH=$(echo "$RAW_MANIFEST" | jq -r '.architecture')
              ARCHS=$( [[ "$ARCH" =~ ^(amd64|arm64|arm|386|ppc64le|s390x|mips64le)$ ]] && echo "$ARCH" || echo "")
            fi
            if [ -z "$ARCHS" ]; then
              echo "âŒ æœªæ‰¾åˆ°æ”¯æŒçš„æ¶æ„ï¼Œä½¿ç”¨é»˜è®¤æ¶æ„ amd64"
              ARCHS="amd64"
            fi
            ARCHS_STR=$(echo "$ARCHS" | tr ',' ' ')
            echo "æœ‰æ•ˆæ¶æ„: $ARCHS_STR"

            # è®¾ç½® IMAGE_NAME (æ­¤éƒ¨åˆ†é€»è¾‘ä¸å˜)
            if [ -z "$current_ghcr_name" ]; then
              IMAGE_NAME=$(basename "$current_image")
            else
              IMAGE_NAME="$current_ghcr_name"
            fi

            declare -a VALID_ARCHS=()
            # ä½¿ç”¨ skopeo inspect æ—¶ï¼Œç”¨ current_image å’Œ current_tag (åŒæ­¥å‰çš„åŸå§‹tagæˆ–é»˜è®¤latest)
            FULL_MANIFEST=$(skopeo inspect --raw "docker://$current_image:$current_tag" | jq .)
            for arch in $ARCHS_STR; do
              echo "ğŸ”„ æ­£åœ¨æ£€æŸ¥ $arch æ¶æ„æ”¯æŒ..."
              if echo "$FULL_MANIFEST" | jq -e --arg arch "$arch" '.manifests[] | select(.platform.architecture == $arch)' >/dev/null 2>&1; then
                echo "âœ”ï¸ ç¡®è®¤å­˜åœ¨ $arch æ¶æ„é•œåƒ"
                VALID_ARCHS+=("$arch")
                echo "ğŸš€ æ­£åœ¨åŒæ­¥ $arch æ¶æ„..."
                echo "$GITHUB_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
                # æ‹‰å–æ—¶ç”¨ current_image å’Œ current_tag
                docker pull --platform "linux/$arch" "$current_image:$current_tag"
                # æ‰“æ ‡ç­¾æ—¶ç”¨ target_tag
                docker tag "$current_image:$current_tag" \
                  "ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag-$arch"
                docker push "ghcr.io/${GHCR_USER}/$IMAGE_NAME:$target_tag-$arch"
              else
                echo "âš ï¸ è­¦å‘Šï¼šæ‰¾ä¸åˆ° $arch æ¶æ„é•œåƒï¼Œå·²è·³è¿‡"
              fi
              echo "----------------------------------------"
            done
            if [ ${#VALID_ARCHS[@]} -eq 0 ]; then
              echo "âŒ æ‰€æœ‰æŒ‡å®šæ¶æ„å‡ä¸å­˜åœ¨ï¼Œåœæ­¢åŒæ­¥"
              continue
            fi

            # åˆ›å»ºå¤šæ¶æ„ Manifest (ä½¿ç”¨ target_tag)
            declare -a MANIFEST_ARGS=()
            for arch in ${VALID_ARCHS[@]}; do
              MANIFEST_ARGS+=(--amend "ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME:$target_tag-$arch")
            done
            echo "ğŸ› ï¸ åˆ›å»ºå¤šæ¶æ„æ¸…å•..."
            docker manifest create "ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME:$target_tag" \
              "${MANIFEST_ARGS[@]}" --insecure
            echo "ğŸšš æ¨é€æ¸…å•..."
            docker manifest push "ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME:$target_tag"

            # æ¸…ç†ä¸´æ—¶é•œåƒï¼ˆåªåˆ é™¤æœ¬æ¬¡åŒæ­¥äº§ç”Ÿçš„ tagï¼Œä¸ prune å…¨éƒ¨ï¼‰
            for arch in ${VALID_ARCHS[@]}; do
              docker rmi "ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME:$target_tag-$arch" || true
            done

            # åˆ›å»º docker-compose.yaml æ–‡ä»¶ (æ­¤éƒ¨åˆ†é€»è¾‘ä¸å˜)
            mkdir -p docker-compose
            cp docker-compose/example.yaml docker-compose/$IMAGE_NAME.yaml # ä½¿ç”¨ IMAGE_NAME (å¯èƒ½æ˜¯ ghcr_name æˆ– basename)
            git config --global user.name "GitHub Actions"
            git config --global user.email "actions@github.com"
            git add docker-compose/$IMAGE_NAME.yaml
            git commit -m "æ·»åŠ  $IMAGE_NAME.yaml æ–‡ä»¶" || true # ä½¿ç”¨ IMAGE_NAME
            git pull --rebase origin main
            git push origin main

            # æ›´æ–° README.md æ–‡ä»¶
            # === ä¼˜åŒ– README.md é•œåƒè¡¨æ ¼å»é‡é€»è¾‘ï¼ˆåŒæ­¥å‰åˆ¤æ–­ç¬¬äºŒåˆ—æ˜¯å¦å·²å­˜åœ¨ï¼‰ ===
            # è·å–å·²å­˜åœ¨çš„æºé•œåƒï¼ˆç¬¬äºŒåˆ—ï¼Œå«æ ‡ç­¾ï¼‰ï¼Œè¿™äº›æºé•œåƒæ˜¯å·²ç»æ¸…ç†è¿‡ç©ºæ ¼çš„
            # awk æå–æ—¶ï¼Œç¡®ä¿å­—æ®µå¤„ç†çš„é²æ£’æ€§
            existing_sources_from_readme=$(awk -F '|' '
                /^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/ {capture=1; next}
                capture && /^\| *[0-9]+ *\|/ { # å…è®¸æ•°å­—å’Œç®¡é“ç¬¦å‘¨å›´æœ‰ç©ºæ ¼
                    # æå–ç¬¬äºŒä¸ªæœ‰æ•ˆå­—æ®µï¼ˆå³æºé•œåƒåˆ—ï¼‰
                    # ä½¿ç”¨ match æ¥æ›´ç²¾ç¡®åœ°æå–è¢«ç®¡é“ç¬¦åŒ…å›´çš„åˆ—å†…å®¹
                    if (match($0, /^\|[^|]*\|([^|]*)\|/, col_array)) {
                        source_img = col_array[1];
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", source_img); # æ¸…ç†æå–å‡ºçš„åˆ—å†…å®¹çš„å‰åç©ºæ ¼
                        if (source_img != "") print source_img; # æ‰“å°éç©ºç»“æœ
                    }
                }
                /^[^|]/ && capture {capture=0} # è¡¨æ ¼ç»“æŸ
            ' README.md | sed '/^$/d') # å†æ¬¡ç”¨ sed å»é™¤å¯èƒ½çš„ç©ºè¡Œ

            # åˆ¤æ–­å½“å‰ full_image (å·²ç»æ¸…ç†è¿‡ç©ºæ ¼å¹¶ç¡®ä¿æœ‰æ ‡ç­¾) æ˜¯å¦å·²å­˜åœ¨äº existing_sources_from_readme
            already_exists=false
            if echo "${existing_sources_from_readme}" | grep -qxF "$full_image"; then
              already_exists=true
            fi

            if $already_exists; then
              echo "é•œåƒ $full_image å·²å­˜åœ¨äº README è¡¨æ ¼ï¼Œè·³è¿‡æ·»åŠ ã€‚"
            else
              echo "æ·»åŠ æ–°é•œåƒ $full_image åˆ° README"
              
              # è·å–ç°æœ‰çš„å®é™…æ•°æ®è¡Œ (ä¸åŒ…æ‹¬è¡¨å¤´å’Œåˆ†éš”çº¿)ï¼Œç”¨äºé‡å»ºè¡¨æ ¼å’Œè®¡ç®—è¡Œå·
              data_lines=$(sed -n '/^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/,/^[^|]/ { /^\| [0-9]/p }' README.md)

              count=$(echo "$data_lines" | wc -l)
              # å¦‚æœ data_lines ä¸ºç©º (æ¯”å¦‚ç¬¬ä¸€æ¬¡æ·»åŠ ï¼Œæˆ– README è¢«æ„å¤–ä¿®æ”¹)ï¼Œwc -l ç»“æœå¯èƒ½æ˜¯1æˆ–0ï¼Œå–å†³äºå…·ä½“å®ç°
              # æ›´å®‰å…¨çš„åšæ³•æ˜¯æ£€æŸ¥ data_lines æ˜¯å¦ä¸ºç©ºå­—ç¬¦ä¸²
              if [ -z "$data_lines" ]; then
                count=0
              fi
              new_count=$((count + 1))

              # pull_cmd ä½¿ç”¨ target_tag
              pull_cmd_val="ghcr.nju.edu.cn/${{ env.GHCR_USER }}/$IMAGE_NAME:$target_tag"
              if [[ "$target_tag" == "latest" ]]; then
                pull_cmd_val="${pull_cmd_val%:latest}" # å¦‚æœæ˜¯latestï¼Œåˆ™ç§»é™¤æ ‡ç­¾åç¼€
              fi
              pull_cmd_markdown="\`$pull_cmd_val\`" # Markdownä»£ç å—æ ¼å¼

              compose_file_markdown="[yaml](https://github.com/${{ github.repository }}/blob/main/docker-compose/$IMAGE_NAME.yaml)"
              
              # display_image_name åº”è¯¥æ˜¯æ¸…ç†å¹¶æ ‡ç­¾åŒ–åçš„ full_image
              display_image_name="$full_image"
              
              # ä½¿ç”¨ printf ç”Ÿæˆæ–°è¡Œï¼Œç¡®ä¿æ ¼å¼ä¸€è‡´
              printf -v new_row "| %-3s | %-30s | %-48s | %-100s | %-3s |\n" "$new_count" "$display_image_name" "$pull_cmd_markdown" "$compose_file_markdown" "$sync_status"
              
              # ä½¿ç”¨åŸè„šæœ¬çš„ awk æ–¹æ³•æ›´æ–° READMEï¼Œè¿™ç§æ–¹æ³•æ˜¯æ›¿æ¢æ•´ä¸ªè¡¨æ ¼å†…å®¹
              # å®ƒä¾èµ–äº new_table_content.txt åŒ…å«å®Œæ•´çš„è¡¨å¤´ã€å·²å­˜åœ¨çš„æ•°æ®è¡Œï¼ˆå¦‚æœæœ‰ï¼‰å’Œæ–°æ•°æ®è¡Œ
              {
                echo "### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ"
                echo ""
                echo "|   | æºé•œåƒ | pull é•œåƒ | docker-compose | åŒæ­¥ |"
                echo "| ---- | -------- | --------- | -------------- | ---- |"
                if [ -n "$data_lines" ]; then # åªæœ‰å½“ data_lines éç©ºæ—¶æ‰æ‰“å°
                    echo "$data_lines" # data_lines æœ¬èº«åŒ…å«æ¢è¡Œç¬¦
                fi
                echo -n "$new_row" # new_row ç”± printf ç”Ÿæˆï¼Œæœ«å°¾å·²æœ‰æ¢è¡Œç¬¦ï¼Œç”¨ echo -n é¿å…é¢å¤–æ¢è¡Œ
              } > new_table_content.txt

              # è¿™ä¸ª awk å‘½ä»¤ä¼šæ‰¾åˆ°æ ‡è®°è¡Œï¼Œç„¶åç”¨ new_table_content.txt çš„å†…å®¹æ›¿æ¢æ‰ README ä¸­ä»æ ‡è®°è¡Œå¼€å§‹åˆ°ç¬¬ä¸€ä¸ªéè¡¨æ ¼è¡Œä¹‹é—´çš„å†…å®¹
              awk '
                /^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/ {
                  # æ‰“å° new_table_content.txt çš„æ‰€æœ‰è¡Œ
                  while ((getline line < "new_table_content.txt") > 0) {
                    print line
                  }
                  close("new_table_content.txt")
                  # è·³è¿‡ README.md ä¸­æ—§çš„è¡¨æ ¼å†…å®¹
                  while ((getline) > 0) {
                    if (line !~ /^\|/ && line !~ /^### æœ¬ä»“åº“å·²åŒæ­¥çš„ Docker é•œåƒ/) { # æ‰¾åˆ°ç¬¬ä¸€ä¸ªéè¡¨æ ¼è¡Œï¼ˆä¸”ä¸æ˜¯æˆ‘ä»¬åˆšæ‰“å°çš„æ ‡è®°è¡Œï¼‰
                      print line # æ‰“å°è¿™ä¸ªéè¡¨æ ¼è¡Œ
                      break      # åœæ­¢æ¶ˆè€—æ—§è¡¨æ ¼è¡Œ
                    }
                  }
                  next
                }
                { print } # æ‰“å°å…¶ä»–æ‰€æœ‰è¡Œ
              ' README.md > README.tmp && mv README.tmp README.md
              
              # git æ“ä½œ (æ­¤éƒ¨åˆ†é€»è¾‘ä¸å˜)
              git config --global user.name "GitHub Actions"
              git config --global user.email "actions@github.com"
              git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
              git add README.md
              git commit -m "æ›´æ–°README.mdï¼Œæ·»åŠ æ–°çš„é•œåƒè¡¨æ ¼æ¡ç›®: $display_image_name" || true
              git pull --rebase origin main
              git push origin main
            fi
            echo "===== åŒæ­¥å®Œæˆ: $full_image (æ¨é€åˆ° ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME:$target_tag) =====\n"
          done
          # æ‰€æœ‰é•œåƒåŒæ­¥å®Œåå†åšå…¨å±€ pruneï¼ˆå¯é€‰ï¼‰
          docker image prune -a --force
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
